MODULE   Elevator
TITLE   'Elevator Ground Hack'

"
" DEVICE: PAL22V10
"
" This contains the hardware description for a PAL that is inserted into the
" system governing the 5x7 display on an elevator that indicates the floor the
" elevator is on.  It detects when the elevator is attempting to display a 1,
" and instead forces a ground symbol.  On all other signals, it displays the
" true floor number by relaying the input signals.
"
" The display is multiplexed by row, so this waits until a light combination
" is detected that appears only on a 1.  In this case, the second row is a
" pattern only present in a 1 (designs below).  This then begins a counter, and
" on every seventh count, we check again for the pattern only present in a 1.
" As long as this is present, we display the ground symbol multiplexed over the
" seven rows.  When we no longer see the pattern, we again transmit the original
" pattern.
"
" Display patterns: '.' is off (0), '0' is on (1)
" Display for subbasement ('S')
"    . 0 0 0 .
"    0 . . . 0
"    0 . . . .
"    . 0 0 0 .
"    . . . . 0
"    0 . . . 0
"    . 0 0 0 .
"
" Display for basement ('B')
"    0 0 0 0 .
"    . 0 . . 0
"    . 0 . . 0
"    . 0 0 0 .
"    . 0 . . 0
"    . 0 . . 0
"    0 0 0 0 .
"
" Display for a 1:                     Display for ground:
"    . . O . .                              . . O . .
"    . O O . .                              . . O . .
"    . . O . .                              O O O O O
"    . . O . .                              . . . . .
"    . . O . .                              . O O O .
"    . . O . .                              . . . . .
"    . O O O .                              . . O . .
"
" Display for a 2
"    . 0 0 0 .
"    0 . . . 0
"    . . . . 0
"    . 0 0 0 .
"    0 . . . .
"    0 . . . .
"    0 0 0 0 0
"
" Display for a 3
"    . 0 0 0 .
"    0 . . . 0
"    . . . . 0
"    . . 0 0 .
"    . . . . 0
"    0 . . . 0
"    . 0 0 0 .
"
" Display for a 4
"    . . . 0 .
"    . . 0 0 .
"    . 0 . 0 .
"    0 . . 0 .
"    0 0 0 0 0
"    . . . 0 .
"    . . . 0 .
"


"------------------------------------------------------------------------------------------------------------------------------
" pins
"------------------------------------------------------------------------------------------------------------------------------

FastClk    pin    1;              "input   2 MHz clock
In0        pin    2;              "input   leftmost column on 5x7 display (from PAL29M16)
In1        pin    3;              "input   second column from left on 5x7 display (from PAL29M16)
In2        pin    4;              "input   middle column on 5x7 display (from PAL29M16)
In3        pin    5;              "input   fourth column from left on 5x7 display (from PAL29M16)
In4        pin    6;              "input   rightmost column on 5x7 display (from PAL29M16)
Chg        pin    7;              "input   toggles on new row
"          pin    8                unused
"          pin    9                unused
"          pin   10                unused
"          pin   11                unused
"GND       pin   12                power
SlowClk    pin   13;              "input   2 kHz clock
"          pin   14                unused
"          pin   15                unused
"          pin   16                unused
"          pin   17                unused
"          pin   18                unused
Col4       pin   19 ISTYPE 'com'; "output  rightmost column on 5x7 display
Col3       pin   20 ISTYPE 'com'; "output  fourth column from left on 5x7 display
Col2       pin   21 ISTYPE 'com'; "output  middle column on 5x7 display
Col1       pin   22 ISTYPE 'com'; "output  second column on 5x7 display
Col0       pin   23 ISTYPE 'com'; "output  leftmost column on 5x7 display
"VCC       pin   24                power


" Bits to keep track of which row is being displayed
Row2       pin      ISTYPE 'reg'; "        MSB for row counter
Row1       pin      ISTYPE 'reg'; "        Middle bit for row counter
Row0       pin      ISTYPE 'reg'; "        LSB for row counter
LastChg    pin      ISTYPE 'reg'; "        Keeps track of when we change rows



"------------------------------------------------------------------------------------------------------------------------------
" constants
"------------------------------------------------------------------------------------------------------------------------------

" Gets rising edge trigger of Chg input
Changed      = (LastChg $ Chg) & Chg;

" Defines the bits in the state diagram.  Using no-output encoding
ElevatorBits = [ Row2, Row1, Row0 ];

" States for the elevator state machine.  There are two main states: idle, which
" relays what its input is to the output, and ground, which displays the ground
" symbol.  We will consider the idle state to have an unknown row, so we can use
" the eighth possible value of our row counter as the idle searching state

"              [   Row2,   Row1,   Row0 ]
Search       = [      0,      0,      0 ]; " Stay here and relay input while we are not on ground floor
Ground1      = [      0,      0,      1 ]; " Display first row of ground
Ground2      = [      0,      1,      0 ]; " Display second row of ground
Ground3      = [      0,      1,      1 ]; " Display third row of ground
Ground4      = [      1,      0,      0 ]; " Display fourth row of ground
Ground5      = [      1,      0,      1 ]; " Display fifth row of ground
Ground6      = [      1,      1,      0 ]; " Display sixth row of ground
Ground7      = [      1,      1,      1 ]; " Display seventh row of ground



"------------------------------------------------------------------------------------------------------------------------------
" equations
"------------------------------------------------------------------------------------------------------------------------------
EQUATIONS

" Enable outputs
Col0.OE      = 1;
Col1.OE      = 1;
Col2.OE      = 1;
Col3.OE      = 1;
Col4.OE      = 1;

" Use fast clock for state machine.  This will lag the rows by 1/1,000,000 of a second
" ground floor.
ElevatorBits.CLK = FastClk;
LastChg.CLK      = FastClk;



"------------------------------------------------------------------------------------------------------------------------------
" state machine
"------------------------------------------------------------------------------------------------------------------------------

" Searches for an input known to be only in a '1'.  When found, goes to ground
" states until we see an input known not to be in the current row.
STATE_DIAGRAM ElevatorBits

STATE Search:
    " Relay inputs
    Col0    = In0;
    Col1    = In1;
    Col2    = In2;
    Col3    = In3;
    Col4    = In4;
    LastChg = Chg;

    " Check for known '1' pattern.  If found, move to ground state on same row
         IF (Changed &   !In0 &  In1 &  In2 & !In3 & !In4) THEN Ground2 " Display 2nd row of ground
    ELSE                                                        Search  " Continue looking for known pattern

STATE Ground1:
    " Set inputs for first row of ground
    Col0    = 0;
    Col1    = 0;
    Col2    = 1;
    Col3    = 0;
    Col4    = 0;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 &  In1 &  In2 & !In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground2 " If changed row, move to next state
    ELSE                                                         Ground1 " Stay here if no change of row

STATE Ground2:
    " Set inputs for second row of ground
    Col0    = 0;
    Col1    = 0;
    Col2    = 1;
    Col3    = 0;
    Col4    = 0;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 & !In1 &  In2 & !In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground3 " If changed row, move to next state
    ELSE                                                         Ground2 " Stay here if no change of row

STATE Ground3:
    " Set inputs for third row of ground
    Col0    = 1;
    Col1    = 1;
    Col2    = 1;
    Col3    = 1;
    Col4    = 1;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 & !In1 &  In2 & !In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground4 " If changed row, move to next state
    ELSE                                                         Ground3 " Stay here if no change of row

STATE Ground4:
    " Set inputs for fourth row of ground
    Col0    = 0;
    Col1    = 0;
    Col2    = 0;
    Col3    = 0;
    Col4    = 0;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 & !In1 &  In2 & !In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground5 " If changed row, move to next state
    ELSE                                                         Ground4 " Stay here if no change of row

STATE Ground5:
    " Set inputs for fifth row of ground
    Col0    = 0;
    Col1    = 1;
    Col2    = 1;
    Col3    = 1;
    Col4    = 0;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 & !In1 &  In2 & !In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground6 " If changed row, move to next state
    ELSE                                                         Ground5 " Stay here if no change of row

STATE Ground6:
    " Set inputs for sixth row of ground
    Col0    = 0;
    Col1    = 0;
    Col2    = 0;
    Col3    = 0;
    Col4    = 0;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 &  In1 &  In2 &  In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground7 " If changed row, move to next state
    ELSE                                                         Ground6 " Stay here if no change of row

STATE Ground7:
    " Set inputs for seventh row of ground
    Col0    = 0;
    Col1    = 0;
    Col2    = 1;
    Col3    = 0;
    Col4    = 0;
    LastChg = Chg;

    " If there was a change, and we don't see the next row in '1', no longer on ground
         IF (Changed & !(!In0 & !In1 &  In2 & !In3 & !In4)) THEN Search  " Start relaying inputs again
    ELSE IF (Changed)                                       THEN Ground1 " If changed row, move to next state
    ELSE                                                         Ground7 " Stay here if no change of row



END Elevator
