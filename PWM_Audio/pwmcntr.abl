MODULE   pwm
TITLE   'PWM Audio Project'


"PWMCPLD   DEVICE   'ispLSI1016-60LJ44'


" EE 119a  Homework #6;

" Description:
"    This is the hardware description for the audio PWM project described in
"    Homework #6 for EE 119a


" Revision History:
"    5/16/99   Glen George     Initial Revision (from 5/9/99 version of
"                                 pwmpins.ldf)
"    5/18/99   Glen George     Updated counters for timing (made
"                                 non-synchronous)
"                              Fixed counter logic to be sure it doesn't count
"                                 while resetting
"    5/27/99   Glen George     Fixed PWM counter logic, reset was wrong on
"                                 bits 1 and 2
"                              Fixed address counter logic, AddrInc should not
"                                 be in carry logic
"    11/10/99  Glen George     Updated comments
"    11/21/00  Glen George     Translated from LDF to ABEL
"    11/16/05  Glen George     Reordered pins and updated comments
"    11/17/07  Glen George     Updated comments
"    11/08/16  Tim Menninger   Implemented audio PWM according to HW6


"--------------------------------------------------------------------------------------------------
" pin definitions and descriptions
"--------------------------------------------------------------------------------------------------
" clock input
CLK32           PIN  11;                            " in    global clock pin (32 MHz)

" PWM output
AudioPWMOut     PIN  10  ISTYPE 'com';              " out   PWM output

" switch inputs
SW1             PIN  28;                            " in    switch #1 input - active high
SW2             PIN  27;                            " in    switch #2 input - active high
SW3             PIN  26;                            " in    switch #3 input - active high
SW4             PIN  25;                            " in    switch #4 input - active high

" ROM data bus inputs
AudioData7      PIN  15;                            " in    audio data, bit 7
AudioData6      PIN  16;                            " in    audio data, bit 6
AudioData5      PIN  17;                            " in    audio data, bit 5
AudioData4      PIN  18;                            " in    audio data, bit 4
AudioData3      PIN  19;                            " in    audio data, bit 3
AudioData2      PIN  20;                            " in    audio data, bit 2
AudioData1      PIN  21;                            " in    audio data, bit 1
AudioData0      PIN  22;                            " in    audio data, bit 0

" ROM address bus outputs
AudioAddr18     PIN  29  ISTYPE 'reg';              " out   audio ROM address, bit 18
AudioAddr17     PIN  30  ISTYPE 'reg';              " out   audio ROM address, bit 17
AudioAddr16     PIN  31  ISTYPE 'reg';              " out   audio ROM address, bit 16
AudioAddr15     PIN  32  ISTYPE 'reg';              " out   audio ROM address, bit 15
AudioAddr14     PIN  37  ISTYPE 'reg';              " out   audio ROM address, bit 14
AudioAddr13     PIN  38  ISTYPE 'reg';              " out   audio ROM address, bit 13
AudioAddr12     PIN  39  ISTYPE 'reg';              " out   audio ROM address, bit 12
AudioAddr11     PIN  40  ISTYPE 'reg';              " out   audio ROM address, bit 11
AudioAddr10     PIN  41  ISTYPE 'reg';              " out   audio ROM address, bit 10
AudioAddr9      PIN  42  ISTYPE 'reg';              " out   audio ROM address, bit 9
AudioAddr8      PIN  43  ISTYPE 'reg';              " out   audio ROM address, bit 8
AudioAddr7      PIN  44  ISTYPE 'reg';              " out   audio ROM address, bit 7
AudioAddr6      PIN   3  ISTYPE 'reg';              " out   audio ROM address, bit 6
AudioAddr5      PIN   4  ISTYPE 'reg';              " out   audio ROM address, bit 5
AudioAddr4      PIN   5  ISTYPE 'reg';              " out   audio ROM address, bit 4
AudioAddr3      PIN   6  ISTYPE 'reg';              " out   audio ROM address, bit 3
AudioAddr2      PIN   7  ISTYPE 'reg';              " out   audio ROM address, bit 2
AudioAddr1      PIN   8  ISTYPE 'reg';              " out   audio ROM address, bit 1
AudioAddr0      PIN   9  ISTYPE 'reg';              " out   audio ROM address, bit 0


"--------------------------------------------------------------------------------------------------
" internal nodes for computation
"--------------------------------------------------------------------------------------------------
" Audio data stored for PWM counter/setter to use
DataBit0        NODE     ISTYPE 'reg';              " bit 0 of the newest audio data
DataBit1        NODE     ISTYPE 'reg';              " bit 1 of the newest audio data
DataBit2        NODE     ISTYPE 'reg';              " bit 2 of the newest audio data
DataBit3        NODE     ISTYPE 'reg';              " bit 3 of the newest audio data
DataBit4        NODE     ISTYPE 'reg';              " bit 4 of the newest audio data
DataBit5        NODE     ISTYPE 'reg';              " bit 5 of the newest audio data
DataBit6        NODE     ISTYPE 'reg';              " bit 6 of the newest audio data
DataBit7        NODE     ISTYPE 'reg';              " bit 7 of the newest audio data

" PWM Counter (12 bits -> 32 MHz / 4096 = 8 KHz)
PWMCount0       NODE     ISTYPE 'reg';              " bit 0 of the PWM counter
PWMCount1       NODE     ISTYPE 'reg';              " bit 1 of the PWM counter
PWMCount2       NODE     ISTYPE 'reg';              " bit 2 of the PWM counter
PWMCount3       NODE     ISTYPE 'reg';              " bit 3 of the PWM counter
PWMCount4       NODE     ISTYPE 'reg';              " bit 4 of the PWM counter
PWMCount5       NODE     ISTYPE 'reg';              " bit 5 of the PWM counter
PWMCount6       NODE     ISTYPE 'reg';              " bit 6 of the PWM counter
PWMCount7       NODE     ISTYPE 'reg';              " bit 7 of the PWM counter

" Counts 16 PWM cycles to satisfy 8kHz frequency.  Address is clocked when this is 1111B
AddrClock0      NODE     ISTYPE 'reg';              " Counts 16 PWM cycles (bit 0)
AddrClock1      NODE     ISTYPE 'reg';              " Counts 16 PWM cycles (bit 1)
AddrClock2      NODE     ISTYPE 'reg';              " Counts 16 PWM cycles (bit 2)
AddrClock3      NODE     ISTYPE 'reg';              " Counts 16 PWM cycles (bit 3)

" Compute the next address when incrementing normally.  These are nodes and not macros
" so we can use bus/set notation
NextAddr0       NODE     ISTYPE 'com';              " bit 0 of the next address on normal increment
NextAddr1       NODE     ISTYPE 'com';              " bit 1 of the next address on normal increment
NextAddr2       NODE     ISTYPE 'com';              " bit 2 of the next address on normal increment
NextAddr3       NODE     ISTYPE 'com';              " bit 3 of the next address on normal increment
NextAddr4       NODE     ISTYPE 'com';              " bit 4 of the next address on normal increment
NextAddr5       NODE     ISTYPE 'com';              " bit 5 of the next address on normal increment
NextAddr6       NODE     ISTYPE 'com';              " bit 6 of the next address on normal increment
NextAddr7       NODE     ISTYPE 'com';              " bit 7 of the next address on normal increment
NextAddr8       NODE     ISTYPE 'com';              " bit 8 of the next address on normal increment
NextAddr9       NODE     ISTYPE 'com';              " bit 9 of the next address on normal increment
NextAddr10      NODE     ISTYPE 'com';              " bit 10 of the next address on normal increment
NextAddr11      NODE     ISTYPE 'com';              " bit 11 of the next address on normal increment
NextAddr12      NODE     ISTYPE 'com';              " bit 12 of the next address on normal increment
NextAddr13      NODE     ISTYPE 'com';              " bit 13 of the next address on normal increment
NextAddr14      NODE     ISTYPE 'com';              " bit 14 of the next address on normal increment
NextAddr15      NODE     ISTYPE 'com';              " bit 15 of the next address on normal increment
NextAddr16      NODE     ISTYPE 'com';              " bit 16 of the next address on normal increment
NextAddr17      NODE     ISTYPE 'com';              " bit 17 of the next address on normal increment
NextAddr18      NODE     ISTYPE 'com';              " bit 18 of the next address on normal increment

" Signals used for clocking purposes
PWMCycle        NODE     ISTYPE 'reg';              " clock for 16-PWM counter
AddrInc         NODE     ISTYPE 'reg';              " clock for PWM address counter

" State bits for addressing state machine
Bit1            NODE     ISTYPE 'reg';              " bit 1 in state encoding for addressing
Bit0            NODE     ISTYPE 'reg';              " bit 0 in state encoding for addressing

" Stores running/not running state, used primarily to detect buttonpush edges
Run             NODE     ISTYPE 'reg';              " run the counters


"--------------------------------------------------------------------------------------------------
" macros for readability
"--------------------------------------------------------------------------------------------------
" shortcuts
C = .C.;
P = .P.;
X = .X.;

" buses
AudioAddr = [AudioAddr18..AudioAddr0];              " ROM address for audio data
AudioData = [DataBit7..DataBit0];                   " registered audio data from ROM
DataIn    = [AudioData7..AudioData0];               " audio data input from ROM
PWMCount  = [PWMCount7..PWMCount0];                 " PWM counter (LFSR)
AddrClock = [AddrClock3..AddrClock0];               " Counts 16 PWM cycles
NextAddr  = [NextAddr18..NextAddr0];                " next address value when counting

" properties
PLSI PROPERTY 'Y1_AS_RESET ON';                     " use Y1 as reset
PLSI PROPERTY 'CLK  AddrInc  CLK0';                 " AddrInc is a product term clock
PLSI PROPERTY 'CLK  PWMCycle CLK1';                 " PWMCycle is a product term clock

" Shorthand to detect buttonpushes
SW1Edge    = !Run &  SW1 & !SW2 & !SW3 & !SW4; " button 1 edge pushed
SW2Edge    = !Run & !SW1 &  SW2 & !SW3 & !SW4; " button 2 edge pushed
SW3Edge    = !Run & !SW1 & !SW2 &  SW3 & !SW4; " button 3 edge pushed
SW4Edge    = !Run & !SW1 & !SW2 & !SW3 &  SW4; " button 4 edge pushed

" Shorthand for zeroing values (PWM zeroed to suppress outputs, addr for testing)
DataZero  = 0;

" When the PWM LFSR counter is 0, it is stuck, so we need to detect that
PWMZeroed = !PWMCount7 & !PWMCount6 & !PWMCount5 & !PWMCount4 &
            !PWMCount3 & !PWMCount2 & !PWMCount1 & !PWMCount0;

" Keeps track of bits that are equal between the audio data and the PWM count, used for comparison
Eq7 = (PWMCount7 & DataBit7) # (!PWMCount7 & !DataBit7);
Eq6 = (PWMCount6 & DataBit6) # (!PWMCount6 & !DataBit6);
Eq5 = (PWMCount5 & DataBit5) # (!PWMCount5 & !DataBit5);
Eq4 = (PWMCount4 & DataBit4) # (!PWMCount4 & !DataBit4);
Eq3 = (PWMCount3 & DataBit3) # (!PWMCount3 & !DataBit3);
Eq2 = (PWMCount2 & DataBit2) # (!PWMCount2 & !DataBit2);
Eq1 = (PWMCount1 & DataBit1) # (!PWMCount1 & !DataBit1);
Eq0 = (PWMCount0 & DataBit0) # (!PWMCount0 & !DataBit0);

" Audio Data (ROM) Address Counter
"    19-bit counter
"    clocked off the AddrInc signal
"    has carry lookahead every 3 bits for routing
"
" Use this to compute the next address in the counter.  These are shorthand, because
" it is possible that we want to hard-set the address when a button is pressed

" carry lookahead is computed for every 3 bits and they ripple
AudioAddrCin3   =                   AudioAddr0  & AudioAddr1  & AudioAddr2;
AudioAddrCin6   =  AudioAddrCin3  & AudioAddr3  & AudioAddr4  & AudioAddr5;
AudioAddrCin9   =  AudioAddrCin6  & AudioAddr6  & AudioAddr7  & AudioAddr8;
AudioAddrCin12  =  AudioAddrCin9  & AudioAddr9  & AudioAddr10 & AudioAddr11;
AudioAddrCin15  =  AudioAddrCin12 & AudioAddr12 & AudioAddr13 & AudioAddr14;

" Start addresses corresponding to each of the switches
StartSW1 = ^h7C000;
StartSW2 = ^h58000;
StartSW3 = ^h48000;
StartSW4 = ^h40000;

" Flags set when the end of data is reached for respective switches
" SW1 started at 0x7C000, runs for 0x04000, ends at 0x7FFFF
EndSW1 =                 AudioAddr18 &  AudioAddr17 &  AudioAddr16 & " 0111B = 0x07
          AudioAddr15 &  AudioAddr14 &  AudioAddr13 &  AudioAddr12 & " 1111B = 0x0F
          AudioAddr11 &  AudioAddr10 &  AudioAddr9  &  AudioAddr8  & " 1111B = 0x0F
          AudioAddr7  &  AudioAddr6  &  AudioAddr5  &  AudioAddr4  & " 1111B = 0x0F
          AudioAddr3  &  AudioAddr2  &  AudioAddr1  &  AudioAddr0;   " 1111B = 0x0F
" SW2 started at 0x58000, runs for 0x24000, ends at 0x7BFFF
EndSW2 =                 AudioAddr18 &  AudioAddr17 &  AudioAddr16 & " 0111B = 0x07
          AudioAddr15 & !AudioAddr14 &  AudioAddr13 &  AudioAddr12 & " 1011B = 0x0B
          AudioAddr11 &  AudioAddr10 &  AudioAddr9  &  AudioAddr8  & " 1111B = 0x0F
          AudioAddr7  &  AudioAddr6  &  AudioAddr5  &  AudioAddr4  & " 1111B = 0x0F
          AudioAddr3  &  AudioAddr2  &  AudioAddr1  &  AudioAddr0;   " 1111B = 0x0F
" SW3 started at 0x48000, runs for 0x10000, ends at 0x57FFF
EndSW3 =                 AudioAddr18 & !AudioAddr17 &  AudioAddr16 & " 0101B = 0x05
         !AudioAddr15 &  AudioAddr14 &  AudioAddr13 &  AudioAddr12 & " 0111B = 0x07
          AudioAddr11 &  AudioAddr10 &  AudioAddr9  &  AudioAddr8  & " 1111B = 0x0F
          AudioAddr7  &  AudioAddr6  &  AudioAddr5  &  AudioAddr4  & " 1111B = 0x0F
          AudioAddr3  &  AudioAddr2  &  AudioAddr1  &  AudioAddr0;   " 1111B = 0x0F
" SW4 started at 0x40000, runs for 0x08000, ends at 0x47FFF
EndSW4 =                 AudioAddr18 & !AudioAddr17 & !AudioAddr16 & " 0100B = 0x04
         !AudioAddr15 &  AudioAddr14 &  AudioAddr13 &  AudioAddr12 & " 0111B = 0x07
          AudioAddr11 &  AudioAddr10 &  AudioAddr9  &  AudioAddr8  & " 1111B = 0x0F
          AudioAddr7  &  AudioAddr6  &  AudioAddr5  &  AudioAddr4  & " 1111B = 0x0F
          AudioAddr3  &  AudioAddr2  &  AudioAddr1  &  AudioAddr0;   " 1111B = 0x0F

" We will a state machine that updates the address and data bits on each iteration.
" When it updates the data bits to match the inputs, it is matching the data from
" the previous address.  Then, the address bits are in preparation/setup for the
" next byte of data.  This machine runs on the slow 8kHz clock.
AddrBits    = [ Bit1, Bit0 ];

AddrActive1 = [    0,    1 ]; " Switch 1 is active
AddrActive2 = [    1,    0 ]; " Switch 2 is active
AddrActive3 = [    1,    1 ]; " Switch 3 is active
AddrActive4 = [    0,    0 ]; " Switch 4 is active


"--------------------------------------------------------------------------------------------------
" equations
"--------------------------------------------------------------------------------------------------
EQUATIONS
" Enable outputs
AudioPWMOut.OE = 1;
AudioAddr18.OE = 1;
AudioAddr17.OE = 1;
AudioAddr16.OE = 1;
AudioAddr15.OE = 1;
AudioAddr14.OE = 1;
AudioAddr13.OE = 1;
AudioAddr12.OE = 1;
AudioAddr11.OE = 1;
AudioAddr10.OE = 1;
AudioAddr9.OE  = 1;
AudioAddr8.OE  = 1;
AudioAddr7.OE  = 1;
AudioAddr6.OE  = 1;
AudioAddr5.OE  = 1;
AudioAddr4.OE  = 1;
AudioAddr3.OE  = 1;
AudioAddr2.OE  = 1;
AudioAddr1.OE  = 1;
AudioAddr0.OE  = 1;

" define the Run signal to know when we have valid input
Run.CLK       = AddrInc;
Run           = ( SW1 & !SW2 & !SW3 & !SW4) #
                (!SW1 &  SW2 & !SW3 & !SW4) #
                (!SW1 & !SW2 &  SW3 & !SW4) #
                (!SW1 & !SW2 & !SW3 &  SW4);

" the address counter
" Each bit toggles on carry in.  We don't worry about reset because the state machine resets on
" button edges, or the PWM is suppressed when there is no valid input
NextAddr0     = !AudioAddr0;
NextAddr1     =  AudioAddr1  $ (AudioAddr0);
NextAddr2     =  AudioAddr2  $ (AudioAddr0 & AudioAddr1);
NextAddr3     =  AudioAddr3  $ (AudioAddrCin3);
NextAddr4     =  AudioAddr4  $ (AudioAddrCin3 & AudioAddr3);
NextAddr5     =  AudioAddr5  $ (AudioAddrCin3 & AudioAddr3 & AudioAddr4);
NextAddr6     =  AudioAddr6  $ (AudioAddrCin6);
NextAddr7     =  AudioAddr7  $ (AudioAddrCin6 & AudioAddr6);
NextAddr8     =  AudioAddr8  $ (AudioAddrCin6 & AudioAddr6 & AudioAddr7);
NextAddr9     =  AudioAddr9  $ (AudioAddrCin9);
NextAddr10    =  AudioAddr10 $ (AudioAddrCin9 & AudioAddr9);
NextAddr11    =  AudioAddr11 $ (AudioAddrCin9 & AudioAddr9 & AudioAddr10);
NextAddr12    =  AudioAddr12 $ (AudioAddrCin12);
NextAddr13    =  AudioAddr13 $ (AudioAddrCin12 & AudioAddr12);
NextAddr14    =  AudioAddr14 $ (AudioAddrCin12 & AudioAddr12 & AudioAddr13);
NextAddr15    =  AudioAddr15 $ (AudioAddrCin15);
NextAddr16    =  AudioAddr16 $ (AudioAddrCin15 & AudioAddr15);
NextAddr17    =  AudioAddr17 $ (AudioAddrCin15 & AudioAddr15 & AudioAddr16);
NextAddr18    =  AudioAddr18 $ (AudioAddrCin15 & AudioAddr15 & AudioAddr16 & AudioAddr17);

" System Control Signals
"    signals needed to control the system operation

" carry out of PWM counter clocks the address counter
" do carry out a little early to allow time for address setup
" note that this means the data from the ROM must be latched
" also should clock if trying to reset the counters.
" We will clock on the last input of the 8-bit LFSR, which is 00..01, the
" 16th time (another counter will have value 1111)
AddrInc       = PWMCycle & AddrClock3 & AddrClock2 & AddrClock1 & AddrClock0;
AddrInc.CLK   = CLK32;


"    setup the clock for the audio address counter
AudioAddr.CLK = AddrInc;
AudioData.CLK = AddrInc;
AddrBits.CLK  = AddrInc;

"--------------------------------------------------------------------------------------------------
" state machine for addressing
"--------------------------------------------------------------------------------------------------
" Each state changes outputs and moves to the next state with the following logic:
"       - If there isn't a valid input (given by Run, which is active when exactly one switch
"         is pressed), then it zeroes the data, which disables PWM out.
"       - It then checks for an edge corresponding to the current state.  If detected, it goes
"         to the start of that message.
"       - We then check if the button is pressed and the address is at the end of the message,
"         in which case we reset the address to the start of the message.
"       - Finally, we check each button individually.  We know that there is an active button at
"         this point.  We check which is active and move to that state.  If we stay in the same
"         state, we simply increment the address (because we know it's not an edge).  Otherwise,
"         we move to the start of the message for that button, because if we are in a different
"         state, then we know that it was an edge.  Our catch-all ELSE is for SW4, but if we are
"         at that point in the IF-ELSE, then SW4 active is the only other possibility.
STATE_DIAGRAM AddrBits

STATE AddrActive1: " Button 1 pressed

         IF !Run          THEN AddrActive1 WITH {AudioAddr = NextAddr; AudioData = DataZero}
    ELSE IF SW1Edge       THEN AddrActive1 WITH {AudioAddr = StartSW1; AudioData = DataZero}
    ELSE IF SW1 & EndSW1  THEN AddrActive1 WITH {AudioAddr = StartSW1; AudioData = DataIn}
    ELSE IF SW1           THEN AddrActive1 WITH {AudioAddr = NextAddr; AudioData = DataIn}
    ELSE IF SW2           THEN AddrActive2 WITH {AudioAddr = StartSW2; AudioData = DataZero}
    ELSE IF SW3           THEN AddrActive3 WITH {AudioAddr = StartSW3; AudioData = DataZero}
    ELSE"IF SW4           THEN"AddrActive4 WITH {AudioAddr = StartSW4; AudioData = DataZero}

STATE AddrActive2: " Button 2 pressed

         IF !Run          THEN AddrActive2 WITH {AudioAddr = NextAddr; AudioData = DataZero}
    ELSE IF SW2Edge       THEN AddrActive2 WITH {AudioAddr = StartSW2; AudioData = DataZero}
    ELSE IF SW2 & EndSW2  THEN AddrActive2 WITH {AudioAddr = StartSW2; AudioData = DataIn}
    ELSE IF SW1           THEN AddrActive1 WITH {AudioAddr = StartSW1; AudioData = DataZero}
    ELSE IF SW2           THEN AddrActive2 WITH {AudioAddr = NextAddr; AudioData = DataIn}
    ELSE IF SW3           THEN AddrActive3 WITH {AudioAddr = StartSW3; AudioData = DataZero}
    ELSE"IF SW4           THEN"AddrActive4 WITH {AudioAddr = StartSW4; AudioData = DataZero}

STATE AddrActive3: " Button 3 pressed

         IF !Run          THEN AddrActive3 WITH {AudioAddr = NextAddr; AudioData = DataZero}
    ELSE IF SW3Edge       THEN AddrActive3 WITH {AudioAddr = StartSW3; AudioData = DataZero}
    ELSE IF SW3 & EndSW3  THEN AddrActive3 WITH {AudioAddr = StartSW3; AudioData = DataIn}
    ELSE IF SW1           THEN AddrActive1 WITH {AudioAddr = StartSW1; AudioData = DataZero}
    ELSE IF SW2           THEN AddrActive2 WITH {AudioAddr = StartSW2; AudioData = DataZero}
    ELSE IF SW3           THEN AddrActive3 WITH {AudioAddr = NextAddr; AudioData = DataIn}
    ELSE"IF SW4           THEN"AddrActive4 WITH {AudioAddr = StartSW4; AudioData = DataZero}

STATE AddrActive4: " Button 4 pressed

         IF !Run          THEN AddrActive4 WITH {AudioAddr = NextAddr; AudioData = DataZero}
    ELSE IF SW4Edge       THEN AddrActive4 WITH {AudioAddr = StartSW4; AudioData = DataZero}
    ELSE IF SW4 & EndSW4  THEN AddrActive4 WITH {AudioAddr = StartSW4; AudioData = DataIn}
    ELSE IF SW1           THEN AddrActive1 WITH {AudioAddr = StartSW1; AudioData = DataZero}
    ELSE IF SW2           THEN AddrActive2 WITH {AudioAddr = StartSW2; AudioData = DataZero}
    ELSE IF SW3           THEN AddrActive3 WITH {AudioAddr = StartSW3; AudioData = DataZero}
    ELSE"IF SW4           THEN"AddrActive4 WITH {AudioAddr = NextAddr; AudioData = DataIn}



"--------------------------------------------------------------------------------------------------
" PWM Counter and Output
"--------------------------------------------------------------------------------------------------
" The last state before reset on the PWM counter is 10000000
PWMCycle.CLK    = CLK32;
PWMCycle        =  PWMCount7 & !PWMCount6 & !PWMCount5 & !PWMCount4 &
                  !PWMCount3 & !PWMCount2 & !PWMCount1 & !PWMCount0;

" PWM Counter
"    8-bit LFSR
"    clocked off the 32 MHz clock
"    reset on all-zero state
"    feedback bits: 7, 5, 4, 3
" each bit toggles on carry in or when resetting and the bit is currently set
PWMCount.CLK    = CLK32;
PWMCount0       := PWMZeroed # (PWMCount7 $ PWMCount5 $ PWMCount4 $ PWMCount3); " Feedback
PWMCount1       := PWMCount0; " Shift
PWMCount2       := PWMCount1; " Shift
PWMCount3       := PWMCount2; " Shift
PWMCount4       := PWMCount3; " Shift
PWMCount5       := PWMCount4; " Shift
PWMCount6       := PWMCount5; " Shift
PWMCount7       := PWMCount6; " Shift

" Count PWM cycles
AddrClock.CLK   = PWMCycle;
AddrClock0      = !AddrClock0;
AddrClock1      =  AddrClock1 $ (AddrClock0);
AddrClock2      =  AddrClock2 $ (AddrClock1 & AddrClock0);
AddrClock3      =  AddrClock3 $ (AddrClock2 & AddrClock1 & AddrClock0);

" Set PWM out if the count is less than the data: AudioPWMOut = (PWMCount < AudioData)
AudioPWMOut     = (!PWMCount7 & DataBit7) #
                  (!PWMCount6 & DataBit6 & Eq7) #
                  (!PWMCount5 & DataBit5 & Eq7 & Eq6) #
                  (!PWMCount4 & DataBit4 & Eq7 & Eq6 & Eq5) #
                  (!PWMCount3 & DataBit3 & Eq7 & Eq6 & Eq5 & Eq4) #
                  (!PWMCount2 & DataBit2 & Eq7 & Eq6 & Eq5 & Eq4 & Eq3) #
                  (!PWMCount1 & DataBit1 & Eq7 & Eq6 & Eq5 & Eq4 & Eq3 & Eq2) #
                  (!PWMCount0 & DataBit0 & Eq7 & Eq6 & Eq5 & Eq4 & Eq3 & Eq2 & Eq1);



END pwm
